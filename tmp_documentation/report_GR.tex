%&latex
\documentclass{article}
\usepackage{amsfonts}

\begin{document}

%+Title
\title{Progress Report : ZK4Z2K Implementation: Galois Ring Arithmetics}

\author{Xiyue Su}
\date{\today}
\maketitle
%-Title

%+Abstract
%\begin{abstract}
%    There is abstract text that you should replace with your own. 
%\end{abstract}
%-Abstract

%+Contents
%\tableofcontents
%-Contents

\section{Work Completed}

\subsection{Representation of GR Element}
Any element $\alpha$ of $\mathbb{GR}(2^k,k_0)$ can be written as

$$\alpha = a_0 + a_1 \alpha + \cdots + a_{k_0-1} \alpha^{k_0-1}, a_i \in \mathbb{Z}_{2^k} (i = 0, 1, \cdots , k_0 - 1)$$, where $\alpha$ is the root of a monic basic primitive polynomial $P_{k_0}(\xi)$ of
degree $k_0$. The following arithmetics are needed:

\subsubsection{Integer}
Uses 32-bit or 64-bit unsigned integers and operations like addition, multiplication, shifting and masking. The basic arithmetics of C++ and Intel SSE4 SIMD intrisics supports up to 64 bits multiplication and addition. 

Have already implemented the int$128$ and int$256$ with key operations still to consider about.

\subsubsection{Base Ring}
One element of the base ring $\mathbb{Z}_{2^k}$ representation is mainly based on a $k$-bit integer, and the data functions include addition, multiplication(and modular reduction) and comparison.


\subsubsection{Galois Extension}
The extension ring includes a base ring instance and a monic basic primitive polynomial $P_{k_0}(\xi)$, which is defined by the corresponding Galois Field $\mathbb{GF}(2^{d_0})$ reduction polynomial generated by generating a minimum hamming weight. The current choice of  $P_{k_0}(\xi)$  may not be fully correct.  Sagemath shows this polynomial is primitive(only verified for $\mathbb{Z}_{2^k}$, $k = 2^i$, $i$ from 3 to 64).


We now have experienced challenges regarding the more generic representation and the embedding techniques. However, now we will move on with embedding techniques for a few less time-consuming parameters listed below: 

\begin{table}[htbp]
    \centering
    \caption{Parameters for lifting GR(2^r, k0) to GR(2^r, k0*k1)}
    \begin{tabular}{|c|c|c|}
        \hline
        $k$ & $k_0$ & $k_1$ \\
        \hline
        2 & 2 & 3 \\
        64 & 2 & 2\footnode{does not work on my laptop yet, and i'll try later} \\
        \hline
    \end{tabular}
\end{table}



\section {Ongoing Work and Plan}

\subsection{Modular reduction}
A modular reduction algorithm that can work for the extension ring(with less optimization tricks, which can of course works for the base ring, which will be handy. 

\subsection{Generalize the Extension Ring Design}
Now the galois extension ring can only work for \mathbb{Z}_{2^k}$, but not a general $\mathbb{GR}(\mathbb{R}, k_0)$. The first step is to replace the current representation of the Galois Ring with a more generic one.

\subsection{Building the Towering}
Once a more generic GR is implemented, the towering can be easily built during compilation via using a recursive construction. 

\subsection{Testing}
Comparing the results with sagemath built-in functions, but tricky thing is some of sagemath's ring arithmetics are deprecated, therefore I will try and find out how that affects our work.

This week's goal: several tests will be carried out, including integer, the polynomial $P_{k_0}(\xi)$, and the base ring arithmetics. Also pay more attention to the choices of $P_{k_0}(\xi)$(which might need a Hensel lift?)

\section{Challenges Experienced}

\subsection{Multi-Precision Integer}

In Intel Intrisics, SSE family only supports a up to signed 32-bit packed multiplication (\texttt{\_\_m128i \_mm\_mul\_epi32 (\_\_m128i a, \_\_m128i b)}). So any integers larger than $64$-bit will inevitably needs to manually do the unsign comparison and operates on the packed integers that deals with the overflow from each pack.

In that case, we probably change the optimization target platform(like macOS?) or search for another intrinsics that can provide wider support. Another way is to manually calculate the overflow, but the SIMD efficiency may be harmed greatly.


\subsection{Definition of Galois extension ring}

The more generic definition of Galois extension can also be a headache.


\subsection{Embedding in Galois extension}

For large base rings(e.g. $k =8$) and high lifting factor($k_1$), it is not feasible anymore to rely on sagemath library to find the homorphism from the base ring to the larger one. As a matter of fact, factorization in a larger ring, where \textit{root()} enumrates every possible roots in the ring, is very time-consuming.

A possible way is to implement a certain factorization algorithm, and generate the .



%+Bibliography
\begin{thebibliography}{99}
\bibitem{Label1} Braun, Lennart, et al. "ZK-for-Z2K: MPC-in-the-Head Zero-Knowledge Proofs for Z 2 k." IMA International Conference on Cryptography and Coding. Cham: Springer Nature Switzerland, 2023.
\bibitem {Label2} Intel intrisics guide: \url{https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html}
\bibitem{Label3} Kibler, Maurice. Galois fields and galois rings made easy. Elsevier, 2017.
\bibitem{Label4} Bini, Gilberto, and Flaminio Flamini. Finite commutative rings and their applications. Vol. 680. Springer Science & Business Media, 2012.

\end{thebibliography}
%-Bibliography
%
\end{document}


